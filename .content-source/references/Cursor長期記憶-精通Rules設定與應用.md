好的，這是一份根據您提供的「Rules」功能所製作的詳細教學材料。

-----

## **掌握 Cursor 的長期記憶：精通規則 (Rules) 的設定與應用**

### **學習目標**

完成本單元後，您將能夠：

  * 解釋「規則 (Rules)」的用途，以及它如何作為 AI 的長期記憶。
  * 明確區分**專案規則 (Project Rules)**、**使用者規則 (User Rules)** 和**記憶 (Memories)** 三種類型。
  * 學會使用 MDC 格式建立並設定「專案規則」。
  * 掌握四種不同的專案規則觸發類型 (`Always`, `Auto Attached`, `Agent Requested`, `Manual`)。
  * 應用最佳實踐來撰寫簡潔、高效的規則。
  * 利用指令從現有對話中快速生成規則。

-----

### **第一部分：什麼是規則 (Rules)？**

您可以將「規則」想像成一套**可重複使用的、具有作用域的永久性指令**，用來指導 Agent (聊天) 和 Cmd+K (行內編輯) 的 AI。它們是為您的專案或您個人編碼**上下文、偏好設定或工作流程**的最佳方式。

簡單來說，規則就是您為 AI 設定的\*\*「長期記憶」\*\*。

#### **運作原理**

大型語言模型本身在每次對話之間是沒有記憶的。規則透過在每次請求時，將其內容**自動加入到模型上下文的最前端**來解決這個問題。這為 AI 在生成程式碼、解釋變更或遵循工作流程時，提供了穩定一致的指導。

#### **規則的三種類型**

Cursor 支援三種主要的規則類型：

1.  **專案規則 (Project Rules)**：儲存在專案的 `.cursor/rules` 資料夾中，可被版本控制，作用域僅限於該專案。**這是最強大、最核心的規則類型。**
2.  **使用者規則 (User Rules)**：全域規則，在 Cursor 設定中定義，永遠對您的所有專案生效。
3.  **記憶 (Memories - Beta)**：根據您在聊天中的對話自動生成的規則。

*(備註：舊有的 `.cursorrules` 檔案仍被支援，但已棄用，建議遷移至新的專案規則格式。)*

-----

### **第二部分：【核心】專案規則 (Project Rules)**

專案規則是團隊協作、標準化專案規範的利器。它們儲存在專案內的 `.cursor/rules` 資料夾中，並可以隨著專案一起被版本控制。

**用途：**

  * 編碼關於您程式碼庫的**領域特定知識** (Domain-specific knowledge)。
  * 自動化特定專案的**工作流程或樣板程式碼**。
  * 標準化團隊的**程式碼風格或架構決策**。

#### **規則的類型與觸發時機**

每條專案規則都可以設定不同的觸發類型，以決定它何時該被應用。

| 規則類型 | 觸發條件 | 最佳使用情境 |
| :--- | :--- | :--- |
| **`Always`** | **永遠包含**在此作用域的上下文裡 | 對整個專案或模組都極其重要的核心指令，例如「所有 API 回應都必須是 JSON 格式」。 |
| **`Auto Attached`** | 當符合 `glob` 模式的檔案被引用時才包含 | 針對特定檔案類型的規則，例如「所有 `*.test.ts` 檔案都必須使用 Jest 框架」。 |
| **`Agent Requested`** | AI 根據規則的 `description` **自主決定**是否包含 | 提供可選的工具或知識給 AI，讓它在需要時自行取用。例如一個關於「如何部署到 Staging 環境」的指南。 |
| **`Manual`** | 僅在使用 `@規則名稱` **明確提及**時才包含 | 不常用但很重要的樣板或指令，例如 `@api-boilerplate` 用於快速生成新的 API 檔案。 |

#### **如何撰寫規則 (MDC 格式詳解)**

專案規則使用 `.mdc` (MDC) 格式撰寫，它允許在一個檔案中同時包含**元數據 (metadata)** 和**內容 (content)**。

**範例 MDC 規則 (`rpc-pattern.mdc`)：**

```mdc
---
# --- 上方是元數據 (frontmatter) ---
description: RPC Service boilerplate  # Agent Requested 類型需要此描述，讓 AI 知道這是什麼
globs:                         # Auto Attached 類型需要此匹配模式
  - "**/services/**/*.ts"
alwaysApply: false             # 如果設為 true，則此規則為 Always 類型
# --- 下方是規則的內容 ---
----
- Use our internal RPC pattern when defining services
- Always use snake_case for service names.

@service-template.ts
```

  * **元數據解析**：
      * `description`: 規則的簡短描述，供 `Agent Requested` 類型使用。
      * `globs`: 一個或多個檔案匹配模式，供 `Auto Attached` 類型使用。
      * `alwaysApply`: 如果為 `true`，則此規則變為 `Always` 類型，會忽略 `globs` 設定。如果未設定任何元數據，則預設為 `Manual` 類型。
  * **內容解析**：
      * `----` 分隔線以下是您想告訴 AI 的具體指令。
      * 您可以在內容中用 `@檔案名.ts` 來引用專案中的其他檔案，當規則被觸發時，該檔案的內容也會一併被加入上下文。

#### **建立與產生規則**

1.  **手動建立**：按下 `Cmd + Shift + P` 打開命令面板，輸入並選擇 **"New Cursor Rule"**，即可快速在 `.cursor/rules` 資料夾中建立一個新規則檔案。
2.  **從對話中產生**：當您與 AI 的一段對話非常有價值，包含許多您希望複用的指令時，直接在聊天中輸入 `/Generate Cursor Rules`，AI 就會自動為您總結並生成規則檔案。

#### **巢狀規則 (Nested Rules)**

您可以在專案的任何子目錄中建立自己的 `.cursor/rules` 資料夾，以實現更細粒度的控制。這對於大型單體倉庫 (monorepos) 或包含前端、後端等不同領域的專案特別有用。

-----

### **第三部分：其他規則類型**

#### **使用者規則 (User Rules)**

  * **作用域**：全域，對您的所有專案生效。
  * **設定位置**：`Cursor Settings > Rules`。
  * **格式**：純文字 (Plain text)。
  * **用途**：設定個人偏好，例如回應的語氣或風格。
  * **範例**：`Please reply in a concise style. Avoid unnecessary repetition or filler language.`

#### **記憶 (Memories - Beta)**

  * **作用域**：目前僅限於您所在的 Git 倉庫。
  * **如何運作**：根據您與 AI 的對話，自動在背景生成並應用的規則。
  * **管理**：您可以在 `Cursor Settings > Rules` 中查看和刪除它們。

-----

### **第四部分：最佳實踐與範例**

  * **保持簡潔**：將規則內容控制在 500 行以內。
  * **拆分概念**：將複雜的大規則拆分成多個可組合的小規則。
  * **提供範例**：在規則內容中提供具體的範例或用 `@` 引用樣板檔案。
  * **指令明確**：像撰寫內部技術文件一樣，避免模糊不清的指導。
  * **善用生成**：當您發現自己總是在重複提示 AI 同樣的事情時，就用 `/Generate Cursor Rules` 把它變成永久規則。

-----

### **第五部分：團隊協作與 FAQ**

  * **團隊規則共享**：目前沒有內建的跨專案共享功能。臨時方案是將共用規則存放在一個獨立的 repo 中，然後透過複製或符號連結 (symlink) 的方式引入到各個專案的 `.cursor/rules` 目錄。
  * **常見問題 (FAQ)**
      * **Q: 我的規則為何沒有生效？**
        A: 請檢查規則的觸發類型。`Agent Requested` 需要 `description`，`Auto Attached` 需要 `globs` 模式能正確匹配到您引用的檔案。
      * **Q: 規則可以引用其他檔案嗎？**
        A: 可以，在規則內容中使用 `@檔案名.ts` 即可。
      * **Q: 規則會影響其他 AI 功能嗎？**
        A: 不會。規則只會提供給 Agent (聊天) 和 Cmd+K (行內編輯) 的 AI 模型。