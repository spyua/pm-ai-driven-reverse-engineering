## **掌握 Cursor 的核心：理解與活用「上下文 (Context)」**

### **學習目標**

完成本單元後，您將能夠：
* 說明什麼是「上下文 (Context)」及其在 AI 模型中的作用。
* 區分「意圖 (Intent)」和「狀態 (State)」這兩種上下文類型。
* 理解為何提供精準的上下文是獲得高品質 AI 回應的關鍵。
* 精通在 Cursor 中提供上下文的四種主要方法 (`@` 符號、規則、MCP、動態收集)。
* 根據任務需求，選擇最合適的上下文提供策略。

---

### **第一部分：基礎概念 - AI 如何「思考」？**

在深入探討之前，讓我們先理解幾個基本概念。

* **大型語言模型 (LLM)**：Cursor 背後的 AI 大腦，它透過學習海量資料來預測和生成文字。
* **Token**：模型處理資訊的基本單位，可以是一個單詞的片段、一個完整的詞或一個符號。模型是逐一 Token 進行預測的。

#### **什麼是「上下文 (Context)」？**

當我們在 Cursor 中請求 AI 協助時，**「上下文」就是我們餵給 AI 模型的所有資訊** (輸入 Tokens)，模型會基於這些資訊來預測並生成它應該給出的回應 (輸出 Tokens)。

上下文主要分為兩種類型，它們協同工作，讓 AI 明白「現狀」與「期望」：

1.  **意圖 (Intent Context)**
    * **定義**：您希望 AI **做什麼**。這是「指令性 (prescriptive)」的。
    * **範例**：`"把那個按鈕從藍色改成綠色。"`、`"重構這個函式，讓它更容易閱讀。"`

2.  **狀態 (State Context)**
    * **定義**：當前世界的**客觀事實**。這是「描述性 (descriptive)」的。
    * **範例**：貼上終端機的錯誤訊息、提供相關的程式碼片段、甚至是螢幕截圖。

**一個完美的請求 = 清晰的意圖 + 準確的狀態**
`(您想要什麼) + (目前狀況如何) → 模型 → 理想的行動`

---

### **第二部分：為何上下文如此重要？**

提供給模型的上下文品質，直接決定了它的產出品質。

* **上下文不足**：
    * **產生幻覺 (Hallucinations)**：模型在資訊不足時會試圖猜測，導致產生無中生有或不合邏輯的結果。
    * **效率低下**：`Agent` 模式會花費大量時間自行在程式碼庫中搜索、閱讀檔案來彌補資訊的不足。

* **上下文過多 (但不相關)**：
    * **稀釋訊號**：無關的資訊會干擾模型的判斷，使其難以抓住重點。

**好消息是**：Cursor 的核心設計就包含了上下文感知能力，它會自動引入它認為相關的資訊。但**您的手動引導，能讓 AI 的飛行軌跡更準確。**

---

### **第三部分：在 Cursor 中提供上下文的四種方法**

#### **1. 最直接的方式：`@` 符號**

當您明確知道哪些資訊是相關的，使用 `@` 是最簡單高效的方式。越精準越好。

| 符號 | 範例 | 使用情境 | 潛在缺點 |
| :--- | :--- | :--- | :--- |
| **`@code`** | `@LRUCachedFunction` | 當您知道是哪個具體的函式、類別或常數與您的任務相關時。 | 需要對程式碼庫有較深入的了解。 |
| **`@file`** | `@cache.ts` | 當您知道需要讀取或編輯哪個檔案，但不確定具體位置時。 | 如果檔案很大，可能會包含大量無關的上下文。 |
| **`@folder`** | `@utils/` | 當整個資料夾中的大部分檔案都與您的任務相關時。 | 同上，容易引入過多無關資訊，稀釋訊號。 |

#### **2. 建立長期記憶：規則 (Rules)**

您可以將「規則」視為您希望 AI 擁有的**長期記憶**。非常適合用來儲存團隊的程式碼風格、特定領域的知識、常用的工作流程等。

* **快速生成**：在與 AI 進行了一段富有成效的長對話後，您可以輸入 `/Generate Cursor Rules` 指令，讓 AI 自動從對話中提煉出可複用的規則。

#### **3. 連接外部系統：MCP (進階)**

**MCP (Model Context Protocol)** 是一個擴充層，允許您賦予 Cursor 從**外部**拉取上下文和執行操作的能力。這對於整合內部系統特別有用。

* **常見應用**：
    * **內部文件**：Notion, Confluence, Google Docs
    * **專案管理**：Linear, Jira
* **如何實現**：如果您有可以透過 API 存取這些系統的工具，您可以為其建立一個 MCP 伺服器。

#### **4. 獲取動態資訊：讓 AI 自行收集 (進階)**

這是一個強大的「人機協作」模式，您引導 Agent 執行某些操作以獲取它靜態分析無法得知的**執行期 (runtime) 上下文**。

* **範例流程 (以 Python 為例)**：
    1.  **下達指令**：`"請在 `some_function` 函式的關鍵部分加入 `print` 語句來調試變數 `x` 的值。"`
    2.  **執行程式**：您讓 Agent 在終端機中執行該 Python 檔案或相關測試。
    3.  **分析結果**：Agent 會讀取終端機中印出的 `print` 結果，並根據這個**實際的執行期資訊**來決定下一步的行動或修復 Bug。

---

### **第四部分：總結與最佳實踐**

* **上下文是基石**：有效的 AI 編碼建立在良好的上下文之上，它由「意圖」（您想要的）和「狀態」（客觀存在）組成。
* **精準打擊**：多使用 `@code`、`@file` 等精準的 `@` 符號來引導 AI，而不是完全依賴它的自動上下文收集。
* **知識沉澱**：將可重複使用的知識和團隊規範沉澱為「規則」，提升協作效率。
* **尋求平衡**：上下文不足會導致幻覺和低效；過多無關的上下文會稀釋重點。努力在兩者之間找到最佳平衡點，以獲得最佳結果。

### **補充教材：`#` 符號 - 外科手術般的精準打擊**

在我們討論過的 `@` 符號基礎上，Cursor 還提供了 `#` 符號，專門用來**引用程式碼庫中已經被索引的「程式碼符號 (Code Symbols)」**。

#### **什麼是「程式碼符號」？**

這指的是程式語言中有具體名稱的獨立單元，例如：

  * 函式 (functions)
  * 類別 (classes)
  * 變數 (variables)
  * 常數 (constants)
  * 介面 (interfaces)
  * 型別 (types)

當 Cursor 完成對您專案的索引後，它就能識別出所有這些符號。

#### **`#` 與 `@` 的核心區別**

如果說 `@file` 是告訴 AI：「去這個**房間**裡找東西」，那麼 `#` 就是告訴 AI：「就是**這個**東西，拿去用」。

這是一個更直觀的比較表：

| 符號 | 主要用途 | 精準度 | 範例 |
| :--- | :--- | :--- | :--- |
| **`#`** | **引用特定的「程式碼符號」** | **極高** (函式/類別級別) | `#myFunction`\<br\>`#UserClass` |
| **`@file`** | 引用單一檔案 | **中** (檔案級別) | `@utils.ts` |
| **`@folder`** | 引用整個資料夾 | **低** (資料夾級別) | `@components/` |
| **`@` (通用)** | 引用網頁、文件等 | (不適用於程式碼) | `@https://...`\<br\>`@docs` |

#### **何時使用 `#`？**

**當您明確知道要討論或修改的是哪一個函式或類別時，請務私必用 `#`。**

**優勢：**

1.  **極致精準**：您只會將該符號的相關程式碼作為上下文提供給 AI，排除了檔案中所有其他無關程式碼的干擾。這能大幅提升 AI 回應的準確性。
2.  **無視路徑**：您只需要記得符號的名稱，不需要記得它在哪個檔案、哪個路徑下。只要輸入 `#`，Cursor 就會自動彈出建議列表讓您搜尋和選取。

#### **實戰範例**

假設您有一個函式 `calculateDiscount` 在 `src/utils/pricing.js` 檔案中。

  * **不好的提問 (使用 `@file`)**:
    `"在 @src/utils/pricing.js 中，解釋 calculateDiscount 函式的作用。"`
    *(這樣會把整個檔案都餵給 AI，如果檔案很大，會有很多雜訊)*

  * **絕佳的提問 (使用 `#`)**:
    `"請解釋 #calculateDiscount 的作用。"`
    *(AI 會精準地只看這個函式的程式碼，並給出最相關的回答)*

  * **精準的重構指令**:
    `"請重構 #calculateDiscount 函式，為其增加一個處理負數輸入的錯誤處理機制。"`

-----

### **結論與整合**

您可以將 `#` 視為提供「狀態上下文 (State Context)」**最外科手術般精準的方法**。

  * 當您需要進行**大範圍操作**（如修改檔案格式、總結檔案內容）時，使用 `@file` 或 `@folder`。
  * 當您需要針對**特定程式碼單元**進行提問、解釋、重構或除錯時，優先使用 `#`。

**一個好記的總結：**

> **`@` 用於指定範圍，而 `#` 用於鎖定目標。**